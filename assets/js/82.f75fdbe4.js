(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{434:function(e,n,t){"use strict";t.r(n);var s=t(1),a=Object(s.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"异步更新队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#异步更新队列"}},[e._v("#")]),e._v(" 异步更新队列")]),e._v(" "),n("p",[e._v("下面这段话是来自 Vue 的官网，通过这段话我们大概已经了解了 Vue 异步更新队列的原理了。")]),e._v(" "),n("p",[e._v("Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 Watcher 被多次触发，只会推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。")]),e._v(" "),n("h2",{attrs:{id:"核心代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#核心代码"}},[e._v("#")]),e._v(" 核心代码")]),e._v(" "),n("p",[e._v("在 src/core/util/next-tick.js 中：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import { noop } from 'shared/util'\nimport { handleError } from './error'\nimport { isIOS, isNative } from './env'\n\nconst callbacks = []\nlet pending = false\n\nfunction flushCallbacks () {\n  pending = false\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]()\n  }\n}\n\n// Here we have async deferring wrappers using both microtasks and (macro) tasks.\n// In < 2.4 we used microtasks everywhere, but there are some scenarios where\n// microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using (macro) tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use microtask by default, but expose a way to force (macro) task when\n// needed (e.g. in event handlers attached by v-on).\nlet microTimerFunc\nlet macroTimerFunc\nlet useMacroTask = false\n\n// Determine (macro) task defer implementation.\n// Technically setImmediate should be the ideal choice, but it's only available\n// in IE. The only polyfill that consistently queues the callback after all DOM\n// events triggered in the same loop is by using MessageChannel.\n/* istanbul ignore if */\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else if (typeof MessageChannel !== 'undefined' && (\n  isNative(MessageChannel) ||\n  // PhantomJS\n  MessageChannel.toString() === '[object MessageChannelConstructor]'\n)) {\n  const channel = new MessageChannel()\n  const port = channel.port2\n  channel.port1.onmessage = flushCallbacks\n  macroTimerFunc = () => {\n    port.postMessage(1)\n  }\n} else {\n  /* istanbul ignore next */\n  macroTimerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n\n// Determine microtask defer implementation.\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  microTimerFunc = () => {\n    p.then(flushCallbacks)\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) setTimeout(noop)\n  }\n} else {\n  // fallback to macro\n  microTimerFunc = macroTimerFunc\n}\n\n/**\n * Wrap a function so that if any code inside triggers state change,\n * the changes are queued using a (macro) task instead of a microtask.\n */\nexport function withMacroTask (fn: Function): Function {\n  return fn._withTask || (fn._withTask = function () {\n    useMacroTask = true\n    const res = fn.apply(null, arguments)\n    useMacroTask = false\n    return res\n  })\n}\n\nexport function nextTick (cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    if (useMacroTask) {\n      macroTimerFunc()\n    } else {\n      microTimerFunc()\n    }\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n")])])]),n("p",[e._v("申明了 microTimerFunc 和 macroTimerFunc 2 个变量，它们分别对应的是 micro task 的函数和 macro task 的函数。")]),e._v(" "),n("ul",[n("li",[e._v("对于 macro task 的实现，优先检测是否支持原生 setImmediate，这是一个高版本 IE 和 Edge 才支持的特性，不支持的话再去检测是否支持原生的 MessageChannel，如果也不支持的话就会降级为 setTimeout 0")]),e._v(" "),n("li",[e._v("对于 micro task 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macro task 的实现。")])]),e._v(" "),n("hr"),e._v(" "),n("h3",{attrs:{id:"这里介绍-3-个-nexttick-定义的变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#这里介绍-3-个-nexttick-定义的变量"}},[e._v("#")]),e._v(" 这里介绍 3 个 nextTick 定义的变量")]),e._v(" "),n("ul",[n("li",[e._v("callbacks: 用来存储所以需要执行的回调的数组")]),e._v(" "),n("li",[e._v("pending: 用来标识是否正在执行回调函数")]),e._v(" "),n("li",[e._v("timerFunc: 用来触发执行回调函数")])]),e._v(" "),n("h3",{attrs:{id:"前面两个都比较简单-下面介绍一下-timerfunc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前面两个都比较简单-下面介绍一下-timerfunc"}},[e._v("#")]),e._v(" 前面两个都比较简单，下面介绍一下 timerFunc")]),e._v(" "),n("ul",[n("li",[e._v("首先判断当前环境支不支持 Promise,如果支持，采用 Promise 方式触发回调。")]),e._v(" "),n("li",[e._v("判断支不支持 MutationObserver，如果支持 MutationObserver，则实例化一个观察者对象，观察文本节点发生变化时，触发执行所有回调函数。")]),e._v(" "),n("li",[e._v("判断支不支持 setImmediate，采用 setImmediate")]),e._v(" "),n("li",[e._v("如果以上都不支持，最后采用 setTimeout")])]),e._v(" "),n("hr"),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("数据的变化到 DOM 的重新渲染是一个异步过程，发生在下一个 tick。平时在开发的过程中，比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 nextTick 后执行。比如下面的伪代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("getData(res).then(()=>{\n  this.xxx = res.data\n  this.$nextTick(() => {\n    // 这里我们可以获取变化后的 DOM\n  })\n})\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);