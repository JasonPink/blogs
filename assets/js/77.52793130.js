(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{426:function(n,t,e){"use strict";e.r(t);var s=e(1),o=Object(s.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"高阶组件-hoc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件-hoc"}},[n._v("#")]),n._v(" 高阶组件 HOC")]),n._v(" "),t("h2",{attrs:{id:"什么是高阶组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是高阶组件"}},[n._v("#")]),n._v(" 什么是高阶组件")]),n._v(" "),t("blockquote",[t("p",[n._v("高阶函数是一个将函数作为参数，返回新函数的函数，高阶组件其实就是把组件作为参数，返回新的组件的组件")])]),n._v(" "),t("p",[n._v("高阶组件的根本作用就是解决代码逻辑复用的问题")]),n._v(" "),t("h2",{attrs:{id:"高阶组件的两种形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件的两种形式"}},[n._v("#")]),n._v(" 高阶组件的两种形式")]),n._v(" "),t("h3",{attrs:{id:"属性代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性代理"}},[n._v("#")]),n._v(" 属性代理")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function proxyHOC(WrappedComponent) {\n  return class extends Component {\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n")])])]),t("p",[n._v("优点：")]),n._v(" "),t("ol",[t("li",[n._v("属性代理可以和业务组件低耦合")]),n._v(" "),t("li",[n._v("同样适用于类组件和函数组件")]),n._v(" "),t("li",[n._v("可以完全隔离业务组件的渲染，因为属性代理说白了是一个新的组件，相比反向继承，可以完全控制业务组件是否渲染")]),n._v(" "),t("li",[n._v("可以嵌套使用，多个 HOC 是可以嵌套使用的，而且一般不会限制包装 HOC 的先后顺序。")])]),n._v(" "),t("p",[n._v("缺点：")]),n._v(" "),t("ol",[t("li",[n._v("一般无法直接获取原始组件的状态，如果想要获取，需要 ref 获取组件实例。")]),n._v(" "),t("li",[n._v("无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。")]),n._v(" "),t("li",[n._v("因为本质上是产生了一个新组件，所以需要配合 forwardRef 来转发 ref。")])]),n._v(" "),t("h3",{attrs:{id:"反向继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反向继承"}},[n._v("#")]),n._v(" 反向继承")]),n._v(" "),t("p",[n._v("反向继承和属性代理有一定的区别，在于包装后的组件继承了原始组件本身，所以此时无须再去挂载业务组件。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Index extends React.Component{\n  render(){\n    return <div> hello,world  </div>\n  }\n}\nfunction HOC(Component){\n    return class wrapComponent extends Component{ /* 直接继承需要包装的组件 */\n\n    }\n}\nexport default HOC(Index)\n\n")])])]),t("p",[n._v("优点：")]),n._v(" "),t("ol",[t("li",[n._v("方便获取组件内部状态，比如 state ，props ，生命周期，绑定的事件函数等")]),n._v(" "),t("li",[n._v("es6 继承可以良好继承静态属性。所以无须对静态属性和方法进行额外的处理")])]),n._v(" "),t("p",[n._v("缺点：")]),n._v(" "),t("ol",[t("li",[n._v("函数组件无法使用")]),n._v(" "),t("li",[n._v("和被包装的组件耦合度高，需要知道被包装的原始组件的内部状态，具体做了些什么")]),n._v(" "),t("li",[n._v("如果多个反向继承 hoc 嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个 componentDidMount，当前 componentDidMount 会覆盖上一个 componentDidMount。这样副作用串联起来，影响很大")])]),n._v(" "),t("h2",{attrs:{id:"高阶组件实现权限拦截"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件实现权限拦截"}},[n._v("#")]),n._v(" 高阶组件实现权限拦截")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 注入权限\nexport const Permission = React.createContext([])\n\nexport default function Index(){\n    const [ rootPermission , setRootPermission ] = React.useState([])\n    React.useEffect(()=>{\n        /* 获取权限列表 */\n        getRootPermission().then(res=>{\n            const { code , data } = res as any\n            code === 200 && setRootPermission(data) //  [ 'docList'  , 'tagList' ]\n        })\n    },[])\n    return <Permission.Provider value={rootPermission} >\n         <RootRouter/>\n    </Permission.Provider>\n}\n\n// HOC 编写\n/* 没有权限 */\nfunction NoPermission (){\n    return <div>您暂时没有权限，请联系管理员开通权限！</div>\n}\n/* 编写HOC */\nexport function PermissionHoc(authorization){\n    return function(Component){\n        return function Home (props){\n            const matchPermission =(value,list)=> list.indexOf(value) /* 匹配权限 */\n            return <Permission.Consumer>\n                {\n                    (permissionList) => matchPermission(authorization,permissionList) >= 0 ? <Component  {...props} /> : <NoPermission />\n                }\n            </Permission.Consumer>\n        }\n    }\n}\n\n// 绑定权限\n@PermissionHoc('writeDoc')\nexport default class Index extends React.Component{} // 类组件\n\n\nexport default PermissionHoc('writeTag')(index) //函数组件\n")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);