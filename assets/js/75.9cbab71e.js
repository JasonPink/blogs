(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{429:function(t,n,e){"use strict";e.r(n);var a=e(1),s=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"usecallback-与-usememo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecallback-与-usememo"}},[t._v("#")]),t._v(" useCallback 与 useMemo")]),t._v(" "),n("h2",{attrs:{id:"usecallback"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[t._v("#")]),t._v(" useCallback")]),t._v(" "),n("blockquote",[n("p",[t._v("返回一个函数，只有在依赖项发生变化的时候才会更新（返回一个新的函数）")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export default function App() {\n  const [count2, setCount2] = useState(0);\n\n  const handleClickButton2 = useCallback(() => {\n    setCount2(count2 + 1);\n  }, [count2]);\n\n  return <Button onClickButton={handleClickButton2}>Button2</Button>;\n}\n\n// Button.jsx\nconst Button = ({ onClickButton, children }) => {\n  return (\n    <>\n      <button onClick={onClickButton}>{children}</button>\n      <span>{Math.random()}</span>\n    </>\n  );\n};\n\nexport default React.memo(Button);\n")])])]),n("p",[t._v("Button 组件中的 memo 会对 props 进行一个浅比较，如果 props 没有发生改变，则不会重新渲染此组件")]),t._v(" "),n("h2",{attrs:{id:"usememo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usememo"}},[t._v("#")]),t._v(" useMemo")]),t._v(" "),n("blockquote",[n("p",[t._v("传递一个创建函数和依赖项，创建函数会需要返回一个值，只有在依赖项发生改变的时候，才会重新调用此函数，返回一个新的值。")])]),t._v(" "),n("p",[t._v("下面这段代码，只有当 count 发生变化的时候才会重新执行 useMemo 的第一个参数，返回一个新的对象从而触发子组件的渲染")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const [count, setCount] = useState(0);\n\nconst userInfo = useMemo(() => {\n  return {\n    // ...\n    name: "Jace",\n    age: count\n  };\n}, [count]);\n\nreturn <UserCard userInfo={userInfo}>\n')])])]),n("p",[t._v("另外我们还可以将一些比较耗时，昂贵的计算逻辑放到 useMemo 中，只有当依赖值发生改变的时候才去更新")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const num = useMemo(() => {\n  let num = 0;\n  // 这里使用 count 针对 num 做一些很复杂的计算，当 count 没改变的时候，组件重新渲染就会直接返回之前缓存的值。\n  return num;\n}, [count]);\n\nreturn <div>{num}</div>\n")])])]),n("p",[t._v("当我们通过 context 在组件之间共享数据时，通常会传递一个大的对象作为 value 属性。一般来说，将这个对象缓存起来是个好方法:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const AuthContext = React.createContext({});\n\nfunction AuthProvider({ user, status, forgotPwLink, children }){\n  const memoizedValue = React.useMemo(() => {\n    return {\n      user,\n      status,\n      forgotPwLink,\n    };\n  }, [user, status, forgotPwLink]);\n\n  return (\n    <AuthContext.Provider value={memoizedValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n")])])]),n("p",[t._v("useCallback 的用途与 useMemo 是相同的，但它是专门为函数构建的。我们直接给返回它一个函数，它会记住这个函数，在渲染之间线程化它。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("React.useCallback(function helloWorld(){}, []);\n\n// ...功能相当于:\nReact.useMemo(() => function helloWorld(){}, []);\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);