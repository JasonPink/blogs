(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{365:function(e,n,d){e.exports=d.p+"assets/img/diff1.51815a8a.jpg"},435:function(e,n,d){"use strict";d.r(n);var t=d(1),o=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"diff-算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[e._v("#")]),e._v(" Diff 算法")]),e._v(" "),n("p",[e._v("Diff 算法是一种对比算法。对比新虚拟 Dom 和旧虚拟 Dom,找出更改的虚拟节点,并只更新这个虚拟节点对应的真实节点,而不用更新其他数据没发生改变的节点,实现精准的更新真实 Dom,进而提高效率。新旧虚拟 Dom 对比的时候,只会在同层级进行,不会跨层级比较")]),e._v(" "),n("h2",{attrs:{id:"diff-对比流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#diff-对比流程"}},[e._v("#")]),e._v(" Diff 对比流程")]),e._v(" "),n("p",[e._v("当数据改变时，会触发 setter，并且通过 Dep.notify 去通知所有订阅者 Watcher，订阅者们就会调用 patch 方法，给真实 DOM 打补丁，更新相应的视图。")]),e._v(" "),n("p",[n("img",{attrs:{src:d(365),alt:"diff",title:"diff"}})]),e._v(" "),n("h3",{attrs:{id:"patch-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#patch-方法"}},[e._v("#")]),e._v(" patch 方法")]),e._v(" "),n("p",[e._v("对比当前同层的虚拟节点是否为同一种类型的标签")]),e._v(" "),n("ul",[n("li",[e._v("是：继续执行"),n("strong",[e._v("patchVnode")]),e._v("方法进行深层比对")]),e._v(" "),n("li",[e._v("否：没有必要对比，直接整个节点替换成新虚拟节点")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function patch(oldVnode, newVnode) {\n  // 比较是否为一个类型的节点\n  if (sameVnode(oldVnode, newVnode)) {\n    // 是：继续进行深层比较\n    patchVnode(oldVnode, newVnode)\n  } else {\n    // 否\n    const oldEl = oldVnode.el // 旧虚拟节点的真实DOM节点\n    const parentEle = api.parentNode(oldEl) // 获取父节点\n    createEle(newVnode) // 创建新虚拟节点对应的真实DOM节点\n    if (parentEle !== null) {\n      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素\n      api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点\n      // 设置null，释放内存\n      oldVnode = null\n    }\n  }\n\n  return newVnode\n}\n\n")])])]),n("h3",{attrs:{id:"samevnode-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#samevnode-方法"}},[e._v("#")]),e._v(" sameVnode 方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function sameVnode(oldVnode, newVnode) {\n  return (\n    oldVnode.key === newVnode.key && // key值是否一样\n    oldVnode.tagName === newVnode.tagName && // 标签名是否一样\n    oldVnode.isComment === newVnode.isComment && // 是否都为注释节点\n    isDef(oldVnode.data) === isDef(newVnode.data) && // 是否都定义了data\n    sameInputType(oldVnode, newVnode) // 当标签为input时，type必须是否相同\n  )\n}\n\n")])])]),n("h3",{attrs:{id:"updatechildren-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#updatechildren-方法"}},[e._v("#")]),e._v(" updateChildren 方法")]),e._v(" "),n("p",[e._v("新旧虚拟节点首尾各有两个指针 newS、oldS、newE、oldE,然后会进行相互比较，有五种比较情况：")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("oldS 和 newS 使用 sameVnode 方法进行比较，sameVnode(oldS, newS)")])]),e._v(" "),n("li",[n("p",[e._v("oldS 和 newE 使用 sameVnode 方法进行比较，sameVnode(oldS, newE)")])]),e._v(" "),n("li",[n("p",[e._v("oldE 和 newS 使用 sameVnode 方法进行比较，sameVnode(oldE, newS)")])]),e._v(" "),n("li",[n("p",[e._v("oldE 和 newE 使用 sameVnode 方法进行比较，sameVnode(oldE, newE)")])]),e._v(" "),n("li",[n("p",[e._v("如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -> index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置。")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function updateChildren(parentElm, oldCh, newCh) {\n  let oldStartIdx = 0, newStartIdx = 0\n  let oldEndIdx = oldCh.length - 1\n  let oldStartVnode = oldCh[0]\n  let oldEndVnode = oldCh[oldEndIdx]\n  let newEndIdx = newCh.length - 1\n  let newStartVnode = newCh[0]\n  let newEndVnode = newCh[newEndIdx]\n  let oldKeyToIdx\n  let idxInOld\n  let elmToMove\n  let before\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx]\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx]\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx]\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode)\n      oldStartVnode = oldCh[++oldStartIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) {\n      patchVnode(oldStartVnode, newEndVnode)\n      api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))\n      oldStartVnode = oldCh[++oldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) {\n      patchVnode(oldEndVnode, newStartVnode)\n      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else {\n      // 使用key时的比较\n      if (oldKeyToIdx === undefined) {\n        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表\n      }\n      idxInOld = oldKeyToIdx[newStartVnode.key]\n      if (!idxInOld) {\n        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n        newStartVnode = newCh[++newStartIdx]\n      }\n      else {\n        elmToMove = oldCh[idxInOld]\n        if (elmToMove.sel !== newStartVnode.sel) {\n          api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n        } else {\n          patchVnode(elmToMove, newStartVnode)\n          oldCh[idxInOld] = null\n          api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el\n    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n  }\n}\n\n")])])]),n("h3",{attrs:{id:"为什么-key-值不建议用-index"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么-key-值不建议用-index"}},[e._v("#")]),e._v(" 为什么 key 值不建议用 index")]),e._v(" "),n("ul",[n("li",[e._v("用 index 作为 key 时，在对数据进行，逆序添加，逆序删除等破坏顺序的操作时，会产生没必要的真实 DOM 更新，从而导致效率低")]),e._v(" "),n("li",[e._v("用 index 作为 key 时，如果结构中包含输入类的 DOM，会产生错误的 DOM 更新")]),e._v(" "),n("li",[e._v("如果不对数据进行逆序添加 逆序删除破坏顺序的操作， 只用于列表展示的话 使用 index 作为 Key 没有毛病")])]),e._v(" "),n("h3",{attrs:{id:"参考链接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.cn/post/6994959998283907102?searchId=20240306163033AA7298EE72504E114784",target:"_blank",rel:"noopener noreferrer"}},[e._v("Diff 核心原理"),n("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=o.exports}}]);