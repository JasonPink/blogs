(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{405:function(e,o,n){"use strict";n.r(o);var a=n(1),s=Object(a.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"commonjs"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" commonjs")]),e._v(" "),o("p",[e._v("在 commonjs 规范中，每个 js 文件都是一个单独的模块可以称之为 module。")]),e._v(" "),o("ul",[o("li",[e._v("该模块中包含 commonjs 规范的核心变量：exports、module.exports、require,")]),e._v(" "),o("li",[e._v("exports、module.exports 可以负责对模块中的内容进行导出,")]),e._v(" "),o("li",[e._v("require 函数可以帮助我们导入其他模块（核心模块、自定义模块、第三方库模块）中的内容")])]),e._v(" "),o("h3",{attrs:{id:"commonjs-实现原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-实现原理"}},[e._v("#")]),e._v(" commonjs 实现原理")]),e._v(" "),o("p",[e._v("每个模块文件上存在 module,exports,require 三个变量，这三个变量是没有被定义的，但我们却可以直接使用。在 nodejs 中还存在其它两个变量__filename 和__dirname 变量。")]),e._v(" "),o("p",[e._v("在编译的过程中，实际 commonjs 对 js 代码进行了首尾包装，包装后的样子如下：")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("(function(exports,require,module,__filename,__dirname){\n   const sayName = require('./hello.js')\n    module.exports = function say(){\n        return {\n            name:sayName(),\n            author:'jason'\n        }\n    }\n})\n")])])]),o("h3",{attrs:{id:"require-加载原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#require-加载原理"}},[e._v("#")]),e._v(" require 加载原理")]),e._v(" "),o("p",[e._v("require 的源码大致如下，从代码中可以分析得出：")]),e._v(" "),o("ul",[o("li",[e._v("require 会接收一个参数-文件标识符，然后分析定位文件，从 Module 上查找是否有缓存，如果有缓存直接返回缓存的内容（避免重复加载）")]),e._v(" "),o("li",[e._v("如果没有缓存，会创建一个 module 对象，缓存到 Module 上，然后执行文件，加载完文件，将 loaded 属性设置为 true,然后返回 module.exports 对象")]),e._v(" "),o("li",[o("strong",[e._v("exports 和 module.exports 持有相同引用")]),e._v("，因为最后导出的是 module.exports， 所以对 exports 进行赋值会导致 exports 操作的不再是 module.exports 的引用")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v(" // id 为路径标识符\nfunction require(id) {\n   /* 查找  Module 上有没有已经加载的 js  对象*/\n   const  cachedModule = Module._cache[id]\n\n   /* 如果已经加载了那么直接取走缓存的 exports 对象  */\n  if(cachedModule){\n    return cachedModule.exports\n  }\n\n  /* 创建当前模块的 module  */\n  const module = { exports: {} ,loaded: false , ...}\n\n  /* 将 module 缓存到  Module 的缓存属性中，路径标识符作为 id */\n  Module._cache[id] = module\n  /* 加载文件 */\n  runInThisContext(wrapper('module.exports = \"123\"'))(module.exports, require, module, __filename, __dirname)\n  /* 加载完成 *//\n  module.loaded = true\n  /* 返回值 */\n  return module.exports\n}\n\n")])])]),o("p",[e._v("require 本质上就是一个函数，可以再任何上下文中执行，所以支持动态导入")]),e._v(" "),o("h2",{attrs:{id:"es-module"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#es-module"}},[e._v("#")]),e._v(" ES Module")]),e._v(" "),o("p",[e._v("从 ES6 开始，JavaScript 才真正意义上有自己的模块化规范")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// a.js\nconst name = 'jason'\nconst year = 20\n\nexport {name, year}\n\nexport const say = function(){\n    console.log('hello')\n}\n\nexport default {\n    name,\n    year,\n    say\n}\n\nimport {name, year, say} from './a.js' // 具名导出\nimport main from './a.js' // 默认导出\nimport main, {name, year,say} // 混合导出\nimport main, * as main2 // 混合导出\nimport {name as name2, year as yeaer, say} from './a.js' // 重命名导出\n\n// 重定向导出\nexport * from './a.js'\nexport {name, year, say} from './a.js'\nexport {name as name2, year as yeaer, say} from './a.js'\n\n// 无需导入模块，只运行模块\nimport 'module'\n")])])]),o("h3",{attrs:{id:"es6-module-特性"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#es6-module-特性"}},[e._v("#")]),e._v(" es6 module 特性")]),e._v(" "),o("ul",[o("li",[e._v("静态语法：es6 module 的引入导出都是静态的，import 会自动提升到代码的顶层，import export 不能放在块级作用域或条件语句中")]),e._v(" "),o("li",[e._v("执行特性：与 commonjs 不同，commonjs 同步加载并执行模块代码，"),o("strong",[e._v("es6 模块提前加载并执行模块文件")]),e._v("，es6 模块在预处理阶段分析模块依赖，在执行阶段执行模块，两个阶段都采用深度优先遍历")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// main.js\nconsole.log('main.js开始执行')\nimport say from './a'\nimport say1 from './b'\nconsole.log('main.js执行完毕')\n\n// a.js\nimport b from './b'\nconsole.log('a模块加载')\nexport default  function say (){\n    console.log('hello , world')\n}\n\n\n// b.js\nconsole.log('b模块加载')\nexport default function sayhello(){\n    console.log('hello,world')\n}\n\n// b模块加载\n// a模块加载\n// main.js开始执行\n// main.js执行完毕\n")])])]),o("ul",[o("li",[e._v("使用 import 被导入的模块运行在严格模式下")]),e._v(" "),o("li",[e._v("使用 import 被导入的变量是只读的，可以理解为 const ,无法被赋值")]),e._v(" "),o("li",[e._v("使用 import 被导入的变量是与原变量绑定/引用的，可以理解为 import 导入的变量无论是否为基本类型都是引用传递")])]),e._v(" "),o("h2",{attrs:{id:"总结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),o("ul",[o("li",[e._v("CommonJs 模块由 JS 运行时实现")]),e._v(" "),o("li",[e._v("CommonJs 是单个值导出，本质上导出的就是 exports 属性")]),e._v(" "),o("li",[e._v("CommonJS 是可以动态加载的，对每一个加载都存在缓存，可以有效的解决循环引用问题。")]),e._v(" "),o("li",[e._v("CommonJS 模块同步加载并执行模块文件。")])]),e._v(" "),o("ul",[o("li",[e._v("ES6 Module 静态的，不能放在块级作用域内，代码发生在编译时。")]),e._v(" "),o("li",[e._v("ES6 Module 的值是动态绑定的，可以通过导出方法修改，可以直接访问修改结果。")]),e._v(" "),o("li",[e._v("ES6 Module 可以导出多个属性和方法，可以单个导入导出，混合导入导出。")]),e._v(" "),o("li",[e._v("ES6 模块提前加载并执行模块文件，")]),e._v(" "),o("li",[e._v("ES6 Module 导入模块在严格模式下。")]),e._v(" "),o("li",[e._v("ES6 Module 的特性可以很容易实现 Tree Shaking 和 Code Splitting。")])])])}),[],!1,null,null,null);o.default=s.exports}}]);