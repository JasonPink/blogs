(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{366:function(e,t,n){e.exports=n.p+"assets/img/reactive.c9e2ac37.png"},436:function(e,t,n){"use strict";n.r(t);var a=n(1),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"响应式原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#响应式原理"}},[e._v("#")]),e._v(" 响应式原理")]),e._v(" "),t("h2",{attrs:{id:"object-defineproperty"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty"}},[e._v("#")]),e._v(" Object.defineProperty")]),e._v(" "),t("p",[e._v("Vue2 实现响应式的核心是利用了 ES5 的 Object.defineProperty，给数据添加 getter 和 setter，目的是为了在我们读取数据和操作数据的时候自动执行一些逻辑")]),e._v(" "),t("h3",{attrs:{id:"模拟代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模拟代码"}},[e._v("#")]),e._v(" 模拟代码")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const Observer = function(data) {\n  // 循环修改为每个属性添加get set\n  for (let key in data) {\n    defineReactive(data, key);\n  }\n}\n\nconst defineReactive = function(obj, key) {\n  // 局部变量dep，用于get set内部调用\n  const dep = new Dep();\n  // 获取当前值\n  let val = obj[key];\n  Object.defineProperty(obj, key, {\n    // 设置当前描述属性为可被循环\n    enumerable: true,\n    // 设置当前描述属性可被修改\n    configurable: true,\n    get() {\n      console.log('in get');\n      // 调用依赖收集器中的addSub，用于收集当前属性与Watcher中的依赖关系\n      dep.depend();\n      return val;\n    },\n    set(newVal) {\n      if (newVal === val) {\n        return;\n      }\n      val = newVal;\n      // 当值发生变更时，通知依赖收集器，更新每个需要更新的Watcher，\n      // 这里每个需要更新通过什么断定？dep.subs\n      dep.notify();\n    }\n  });\n}\n\nconst observe = function(data) {\n  return new Observer(data);\n}\n\nconst Vue = function(options) {\n  const self = this;\n  // 将data赋值给this._data，源码这部分用的Proxy所以我们用最简单的方式临时实现\n  if (options && typeof options.data === 'function') {\n    this._data = options.data.apply(this);\n  }\n  // 挂载函数\n  this.mount = function() {\n    new Watcher(self, self.render);\n  }\n  // 渲染函数\n  this.render = function() {\n    with(self) {\n      _data.text;\n    }\n  }\n  // 监听this._data\n  observe(this._data);\n}\n\nconst Watcher = function(vm, fn) {\n  const self = this;\n  this.vm = vm;\n  // 将当前Dep.target指向自己\n  Dep.target = this;\n  // 向Dep方法添加当前Wathcer\n  this.addDep = function(dep) {\n    dep.addSub(self);\n  }\n  // 更新方法，用于触发vm._render\n  this.update = function() {\n    console.log('in watcher update');\n    fn();\n  }\n  // 这里会首次调用vm._render，从而触发text的get\n  // 从而将当前的Wathcer与Dep关联起来\n  this.value = fn();\n  // 这里清空了Dep.target，为了防止notify触发时，不停的绑定Watcher与Dep，\n  // 造成代码死循环\n  Dep.target = null;\n}\n\nconst Dep = function() {\n  const self = this;\n  // 收集目标\n  this.target = null;\n  // 存储收集器中需要通知的Watcher\n  this.subs = [];\n  // 当有目标时，绑定Dep与Wathcer的关系\n  this.depend = function() {\n    if (Dep.target) {\n      // 这里其实可以直接写self.addSub(Dep.target)，\n      // 没有这么写因为想还原源码的过程。\n      Dep.target.addDep(self);\n    }\n  }\n  // 为当前收集器添加Watcher\n  this.addSub = function(watcher) {\n    self.subs.push(watcher);\n  }\n  // 通知收集器中所的所有Wathcer，调用其update方法\n  this.notify = function() {\n    for (let i = 0; i < self.subs.length; i += 1) {\n      self.subs[i].update();\n    }\n  }\n}\n\nconst vue = new Vue({\n  data() {\n    return {\n      text: 'hello world'\n    };\n  }\n})\n\nvue.mount(); // in get\nvue._data.text = '123'; // in watcher update /n in get\n\n")])])]),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("ol",[t("li",[e._v("在 new Vue()时，init 会数据监听，会把 data/props 数据递归放在 Object.defineProperty 中代理，同时依赖收集 Watcher")]),e._v(" "),t("li",[e._v("在 app.$mount(el)时,会执行 new Watcher()，Watcher 构造函数中\n"),t("ol",[t("li",[e._v("会去执行 updateComponent,即先 vm_render()拿到 VNode，vm._update()虚拟 DOM 对比，并更新到真实 DOM。vm_render()又会解析模板，模板中又会使用到 data/props（this.key 会触发 data.key 的 getter 函数）。此时会使用到第一步的数据监听部分（终于把两者串联了），因为 Object.defineProperty 作用就是在拿到 data.key 的同时，还能做一些额外的逻辑（通过 getter/setter）。")]),e._v(" "),t("li",[e._v("getter 中做依赖收集。具体是每个 data.key 都有个 Dep 对象，在 getter 函数中，把当前 Watcher（Dep.target）增加到 Dep 对象")]),e._v(" "),t("li",[e._v("会把当前 Watcher 作为 Dep.target")])])]),e._v(" "),t("li",[e._v("当数据变化时，触发 data.key 的 setter 方法，收集的 Watcher 执行回调。\n"),t("ol",[t("li",[e._v("watcher 队列概念。派发更新的时候，并不会每次数据改变都触发 watcher 的回调，而是在 nextTick 后执行。")]),e._v(" "),t("li",[e._v("watcher 队列执行有规则。1. 先把父组件排在子组件前（根据 id），因为父组件创建过程要先于子组件。2. 用户自定义 watcher 优先于渲染 watcher。")])])])]),e._v(" "),t("p",[t("img",{attrs:{src:n(366),alt:"响应式数据",title:"响应式数据"}})]),e._v(" "),t("h3",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://ustbhuangyi.github.io/vue-analysis/v2/reactive/",target:"_blank",rel:"noopener noreferrer"}},[e._v("响应式原理"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);