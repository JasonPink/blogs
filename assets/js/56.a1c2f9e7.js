(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{403:function(t,e,r){"use strict";r.r(e);var n=r(1),a=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"解构的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解构的原理"}},[t._v("#")]),t._v(" 解构的原理")]),t._v(" "),e("p",[t._v("解构是 ES6 提供的语法糖，内在是针对"),e("strong",[t._v("可迭代对象")]),t._v("的 "),e("strong",[t._v("Iterator")]),t._v(" 接口，通过遍历器按顺序获取对应的值进行赋值")]),t._v(" "),e("p",[t._v("这里有两个重要的概念：")]),t._v(" "),e("ul",[e("li",[t._v("Iterator")]),t._v(" "),e("li",[t._v("可迭代对象")])]),t._v(" "),e("h2",{attrs:{id:"iterator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iterator"}},[t._v("#")]),t._v(" Iterator")]),t._v(" "),e("p",[t._v("Iterator 是一种机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作")]),t._v(" "),e("p",[t._v("Iterator 的遍历过程是这样的")]),t._v(" "),e("ol",[e("li",[t._v("创建一个指针对象，指向当前数据结构的起始位置，遍历器对象本质上就是一个指针对象")]),t._v(" "),e("li",[t._v("第一次调用指针对象的"),e("strong",[t._v("next")]),t._v("方法，可以将指针指向数据结构的第一个成员")]),t._v(" "),e("li",[t._v("第二次调用指针对象的"),e("strong",[t._v("next")]),t._v("方法，指针就指向数据结构的第二个成员")]),t._v(" "),e("li",[t._v("不断调用指针对象的"),e("strong",[t._v("next")]),t._v("方法，直到它指向数据结构的结束位置")])]),t._v(" "),e("p",[t._v("每一次调用 next 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 value 和 done 两个属性的对象。其中，value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function makeIterator(array) {\n    var nextIndex = 0\n    return {\n      next: function() {\n        return nextIndex < array.length ?\n            {value: array[nextIndex++]} :\n            {done: true}\n        }\n    };\n  }\n\n\nvar it = makeIterator([0, 1, 2])\n\nconsole.log(it.next().value) // 0\nconsole.log(it.next().value) // 1\nconsole.log(it.next().value) // 2\n\n")])])]),e("h2",{attrs:{id:"可迭代对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可迭代对象"}},[t._v("#")]),t._v(" 可迭代对象")]),t._v(" "),e("p",[t._v("一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）.默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”（iterable）")]),t._v(" "),e("p",[t._v("原生具备 Iterator 接口的数据结构如下。")]),t._v(" "),e("ul",[e("li",[t._v("Array")]),t._v(" "),e("li",[t._v("Map")]),t._v(" "),e("li",[t._v("Set")]),t._v(" "),e("li",[t._v("String")]),t._v(" "),e("li",[t._v("TypedArray +函数的 arguments 对象")]),t._v(" "),e("li",[t._v("NodeList 对象")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 自定义可迭代对象\nlet obj = {\n    [Symbol.iterator] : function() {\n        return{\n            next: function() {\n                return { value: 1, done: true }\n            }\n        }\n    }\n}\nfor (let item of obj) {\n    console.log(item) // 不会报错，因为obj已经是可迭代对象\n}\n\n")])])]),e("h2",{attrs:{id:"参考文章"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/iterator",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰 ECMAScript 6"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);