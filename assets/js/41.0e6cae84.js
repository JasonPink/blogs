(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{360:function(e,t,r){e.exports=r.p+"assets/img/intersectionOb.a243b5fc.jpg"},361:function(e,t,r){e.exports=r.p+"assets/img/rootmargin.e32c0d41.jpg"},418:function(e,t,r){"use strict";r.r(t);var s=r(1),n=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"intersectionobserver"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#intersectionobserver"}},[e._v("#")]),e._v(" IntersectionObserver")]),e._v(" "),t("p",[e._v("提供了一种创建 IntersectionObserver 对象的方法，对象用于"),t("strong",[e._v("监测目标元素与视窗的交叉状态")]),e._v("，并在交叉状态变化时执行回调函数，回调函数可以接收到元素与视窗交叉的具体数据")]),e._v(" "),t("p",[t("img",{attrs:{src:r(360),alt:"交叉",title:"intersectionOb"}})]),e._v(" "),t("p",[e._v("一个 IntersectionObserver 对象可以监听多个元素")]),e._v(" "),t("p",[e._v("IntersectionObserver 特别适用于：滚动动画、懒加载、虚拟列表等场景")]),e._v(" "),t("h3",{attrs:{id:"使用方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用方法"}},[e._v("#")]),e._v(" 使用方法")]),e._v(" "),t("p",[e._v("IntersectionObserver 构造函数接收两个参数")]),e._v(" "),t("ul",[t("li",[e._v("callback:当元素可见比例达到指定阈值后触发的回调函数")]),e._v(" "),t("li",[e._v("options:\n"),t("ul",[t("li",[e._v("root: 所监听对象的具体祖先元素，默认使用顶级文档的视窗(一般为 html)")]),e._v(" "),t("li",[e._v("rootMargin: 计算交叉时添加到根(root)边界盒 bounding box 的矩形偏移量")]),e._v(" "),t("li",[e._v("threshold: 一个包含阈值的列表, 按升序排列, 列表中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会触发 callback。默认值为 0。\n"),t("img",{attrs:{src:r(361),alt:"threshold",title:"threshold"}})])])])]),e._v(" "),t("p",[e._v("IntersectionObserver 构造函数 返回观察器实例，实例携带四个方法")]),e._v(" "),t("ul",[t("li",[e._v("observe: 开始监听目标元素")]),e._v(" "),t("li",[e._v("unobserve: 停止监听目标元素")]),e._v(" "),t("li",[e._v("disconnect: 关闭观察器")]),e._v(" "),t("li",[e._v("takeRecords: 返回所有观察目标的 IntersectionObserverEntry 对象数组")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 调用构造函数 生成IntersectionObserver观察器\nconst myObserver = new IntersectionObserver(callback, options);\n\n// 开始监听 指定元素\nmyObserver.observe(element);\n\n// 停止对目标的监听\nmyObserver.unobserve(element);\n\n// 关闭观察器\nmyObserver.disconnect();\n")])])]),t("h3",{attrs:{id:"使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[e._v("#")]),e._v(" 使用场景")]),e._v(" "),t("ol",[t("li",[e._v("图片懒加载")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const observer = new IntersectionObserver((entries) => {\n  entries.forEach((entry) => {\n    if (entry.isIntersecting) {\n      const img = entry.target;\n      img.src = img.dataset.src; // 将真实的图片地址赋给 src 属性\n      observer.unobserve(img); // 停止观察该图片\n    }\n  });\n});\n\nconst lazyImages = document.querySelectorAll('.lazy-image');\nlazyImages.forEach((img) => {\n  observer.observe(img); // 开始观察每个图片元素\n});\n\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("无限滚动加载")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const observer = new IntersectionObserver((entries) => {\n  entries.forEach((entry) => {\n    if (entry.isIntersecting) {\n      loadMoreData(); // 触发数据加载操作\n    }\n  });\n});\n\nconst loader = document.querySelector('.loader');\nobserver.observe(loader); // 开始观察加载指示器元素\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);