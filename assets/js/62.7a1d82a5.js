(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{409:function(t,n,a){"use strict";a.r(n);var e=a(1),r=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"防抖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#防抖"}},[t._v("#")]),t._v(" 防抖")]),t._v(" "),n("p",[t._v("在事件触发 n 秒后执行函数，如果在 n 秒内再次触发，重新计时")]),t._v(" "),n("ul",[n("li",[t._v("持续触发不执行")]),t._v(" "),n("li",[t._v("不触发的一段时间之后再执行")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function debounce(fn, wait) {\n    var timeout = null;\n    return function() {\n        if(timeout !== null)\n                clearTimeout(timeout);\n        timeout = setTimeout(fn, wait);\n    }\n}\n\n常用场景 window 的 scroll、resize 事件，input change事件\n")])])]),n("h1",{attrs:{id:"节流"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#节流"}},[t._v("#")]),t._v(" 节流")]),t._v(" "),n("p",[t._v("一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const throttle = function(func, delay) {\n    var prev = Date.now();\n    return function() {\n        var context = this;\n        var args = arguments;\n        var now = Date.now();\n        if (now - prev >= delay) {\n            func.apply(context, args);\n            prev = Date.now();\n        }\n    }\n}\n\n")])])]),n("h2",{attrs:{id:"区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),n("p",[t._v("函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。")])])}),[],!1,null,null,null);n.default=r.exports}}]);